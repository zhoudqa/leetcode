package golang

import "math"

// ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­0/1èƒŒåŒ…ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­//
// ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° target ã€‚
//
// å‘æ•°ç»„ä¸­çš„æ¯ä¸ªæ•´æ•°å‰æ·»åŠ  '+' æˆ– '-' ï¼Œç„¶åä¸²è”èµ·æ‰€æœ‰æ•´æ•°ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ª è¡¨è¾¾å¼ ï¼š
//
// ä¾‹å¦‚ï¼Œnums = [2, 1] ï¼Œå¯ä»¥åœ¨ 2 ä¹‹å‰æ·»åŠ  '+' ï¼Œåœ¨ 1 ä¹‹å‰æ·»åŠ  '-' ï¼Œç„¶åä¸²è”èµ·æ¥å¾—åˆ°è¡¨è¾¾å¼ "+2-1" ã€‚
// è¿”å›å¯ä»¥é€šè¿‡ä¸Šè¿°æ–¹æ³•æ„é€ çš„ã€è¿ç®—ç»“æœç­‰äº target çš„ä¸åŒ è¡¨è¾¾å¼ çš„æ•°ç›®ã€‚
func findTargetSumWays(nums []int, target int) int {
	//éœ€è¦å…ˆæ¨å¯¼å‡ºæ¥ï¼Œè®¾åŠ +çš„æ•°æ€»å’Œä¸ºpï¼ŒåŠ -çš„æ•°æ€»å’Œåˆ™æ˜¯sum-pï¼Œåˆ™å¯ä»¥å¾—åˆ°p-(sum-p)=t => p=(sum+t)/2 å³æ˜¯01ä¸­çš„cap
	var sum int
	for _, num := range nums {
		sum += num
	}
	capacity := target + sum
	//è¾¹ç•Œæ¡ä»¶
	if capacity < 0 || capacity%2 != 0 {
		return 0
	}
	capacity /= 2
	n := len(nums)
	var f = make([][]int, n+1)
	f[0] = make([]int, capacity+1)
	//cap=0çš„æ—¶å€™ï¼Œæ–¹æ¡ˆæ•°ä¸º1ï¼Œf[i][j]ä»£è¡¨åªæœ‰å‰iä¸ªæ•°çš„æƒ…å†µä¸‹ï¼Œå’Œä¸ºjçš„æ–¹æ¡ˆæ•°
	f[0][0] = 1
	for i, num := range nums {
		f[i+1] = make([]int, capacity+1)
		for j := 0; j < capacity+1; j++ {
			if j < num {
				//æ”¾ä¸ä¸‹
				f[i+1][j] = f[i][j]
			} else {
				//é€‰äº†å’Œä¸é€‰çš„æ–¹æ¡ˆæ•°åŠ èµ·æ¥
				f[i+1][j] = f[i][j] + f[i][j-num]
			}
		}
	}
	return f[n][capacity]
}

// ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ coins ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° amount ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚
// è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ æœ€å°‘çš„ç¡¬å¸ä¸ªæ•° ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1 ã€‚
// ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚
func coinChange(coins []int, amount int) int {
	if amount < 0 {
		return -1
	}
	n := len(coins)
	f := make([][]int, n+1)
	//f[i][j]ä»£è¡¨å‰iä¸ªcoinå¯ä»¥ç»„æˆjé‡‘é¢çš„æœ€å°ç¡¬å¸æ•° f[i][j] = min(f[i-1][j],f[i][j-coin[i]]+1)
	f[0] = make([]int, amount+1)
	inf := math.MaxInt / 2
	for i := range f[0] {
		f[0][i] = inf
	}
	//éœ€è¦æ„æˆå’Œä¸º0çš„æœ€å°‘ç¡¬å¸ä¸ªæ•°ä¸º0
	f[0][0] = 0
	for i, x := range coins {
		f[i+1] = make([]int, amount+1)
		for c := 0; c < amount+1; c++ {
			if x > c {
				f[i+1][c] = f[i][c]
			} else {
				//å¯ä»¥æ— é™ä½¿ç”¨ï¼Œæ‰€ä»¥å¯èƒ½ç”¨äº†ç¬¬i+1ä¸ª
				f[i+1][c] = min(f[i][c], f[i+1][c-x]+1)
			}
		}
	}
	res := f[n][amount]
	if res < inf {

		return res
	} else {
		return -1
	}
}
