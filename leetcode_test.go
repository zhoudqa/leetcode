package main

import (
	"sort"
	"testing"
)

func max(a, b int) int {
	if a > b {
		return a
	} else {
		return b
	}
}

func min(a, b int) int {
	if a > b {
		return b
	} else {
		return a
	}
}

// 2396. ä¸¥æ ¼å›æ–‡çš„æ•°å­—
// å¦‚æœä¸€ä¸ªæ•´æ•° n åœ¨ b è¿›åˆ¶ä¸‹ï¼ˆb ä¸º 2 åˆ° n - 2 ä¹‹é—´çš„æ‰€æœ‰æ•´æ•°ï¼‰å¯¹åº”çš„å­—ç¬¦ä¸² å…¨éƒ¨ éƒ½æ˜¯ å›æ–‡çš„ ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°è¿™ä¸ªæ•° n æ˜¯ ä¸¥æ ¼å›æ–‡ çš„ã€‚
// ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œå¦‚æœ n æ˜¯ ä¸¥æ ¼å›æ–‡ çš„ï¼Œè¯·è¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚
// å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä»å‰å¾€åè¯»å’Œä»åå¾€å‰è¯»å®Œå…¨ç›¸åŒï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸²æ˜¯ å›æ–‡çš„ ã€‚
// ä»£æ•°æ±‚ä½™ n=qb+r n>4æ—¶ï¼Œå–b=n-2ï¼Œåˆ™q=1,r=2ï¼Œé‚£ä¹ˆn-2è¿›åˆ¶è¡¨è¾¾å°±æ˜¯12ï¼Œä¸æ˜¯å›æ–‡ï¼Œå½“n=4ï¼ŒäºŒè¿›åˆ¶æ˜¯100ï¼Œä¸æ˜¯å›æ–‡
func isStrictlyPalindromic(n int) bool {
	return false
}

func TestLC(t *testing.T) {
	minSubArrayLen(4, []int{1, 4, 4})
}

//ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­åŠ¨æ€è§„åˆ’ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­//

// å¦‚æœ nums çš„å­é›†ä¸­ï¼Œä»»æ„ä¸¤ä¸ªæ•´æ•°çš„ç»å¯¹å·®å‡ä¸ç­‰äº k ï¼Œåˆ™è®¤ä¸ºè¯¥å­æ•°ç»„æ˜¯ä¸€ä¸ª ç¾ä¸½ å­é›†ã€‚
// è¿”å›æ•°ç»„ nums ä¸­ éç©º ä¸” ç¾ä¸½ çš„å­é›†æ•°ç›®ã€‚
// nums çš„å­é›†å®šä¹‰ä¸ºï¼šå¯ä»¥ç»ç”± nums åˆ é™¤æŸäº›å…ƒç´ ï¼ˆä¹Ÿå¯èƒ½ä¸åˆ é™¤ï¼‰å¾—åˆ°çš„ä¸€ä¸ªæ•°ç»„ã€‚åªæœ‰åœ¨åˆ é™¤å…ƒç´ æ—¶é€‰æ‹©çš„ç´¢å¼•ä¸åŒçš„æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªå­é›†æ‰ä¼šè¢«è§†ä½œæ˜¯ä¸åŒçš„å­é›†ã€‚
func beautifulSubsets(nums []int, k int) int {
	groups := map[int]map[int]int{}
	for _, n := range nums {
		m := n % k
		if groups[m] == nil {
			groups[m] = map[int]int{}
		}
		//ä¿å­˜å¯¹åº”æ•°å­—çš„æ•°é‡
		groups[m][n]++
	}
	type pair struct{ num, cnt int }
	ans := 1
	for _, group := range groups {
		//åŒä¸€ä¸ªmodä¸‹é¢çš„åˆ†ç»„
		m := len(group)
		g := make([]pair, 0)
		for num, cnt := range group {
			g = append(g, pair{num: num, cnt: cnt})
		}
		sort.Slice(g, func(i, j int) bool {
			return g[i].num < g[j].num
		})
		f := make([]int, m+1)
		f[0] = 1
		f[1] = 1 << g[0].cnt
		//f[i] è¡¨ç¤ºè€ƒè™‘å‰ i ä¸ª key çš„æ–¹æ¡ˆæ•°
		for i := 1; i < m; i++ {
			if g[i].num-g[i-1].num == k {
				// (ç¬¬içš„æ‰€æœ‰ä¸é€‰i+1) + (ç¬¬i-2çš„æ‰€æœ‰ é€‰äº†i+1+ä¸é€‰i+1(å…¨ä¸é€‰çš„é‚£ç§æƒ…å†µåœ¨f[i]ä¸­åŒ…å«äº†)
				f[i+1] = f[i] + f[i-1]*(1<<g[i].cnt-1)
			} else {
				//ä¹˜æ³•åŸç†ï¼Œé€‰äº†+ä¸é€‰
				f[i+1] = f[i] << g[i].cnt
			}
		}
		ans *= f[m]

	}
	//å»æ‰ç©ºé›†
	return ans - 1
}

// ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
//
// ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
func rob(nums []int) int {
	return robRec(nums)
}

// é€’æ¨&æœ€å°çŠ¶æ€
func robRetMinSpace(nums []int) int {
	f0 := 0
	f1 := 0
	for i := 0; i < len(nums); i++ {
		nextF := max(f0+nums[i], f1)
		f0 = f1
		f1 = nextF
	}
	return f1
}

// é€’æ¨
func robRet(nums []int) int {
	var f = make([]int, len(nums)+2)
	f[0] = 0
	f[1] = 0
	for i := 0; i < len(nums); i++ {
		f[i+2] = max(f[i+1], f[i]+nums[i])
	}
	return f[len(nums)+1]
}

// é€’å½’
func robRec(nums []int) int {
	//f[i]è¡¨ç¤ºå‰iä¸ªæˆ¿å­èƒ½å·åˆ°çš„æœ€å¤§é‡‘é¢
	var cache = make([]int, len(nums))
	for i := 0; i < len(nums); i++ {
		cache[i] = -1
	}
	var dfs func(i int) int
	dfs = func(i int) int {
		if i < 0 { // é€’å½’è¾¹ç•Œï¼ˆæ²¡æœ‰æˆ¿å­ï¼‰
			return 0
		}
		if cache[i] != -1 {
			return cache[i]
		}
		cache[i] = max(nums[i]+dfs(i-2), dfs(i-1))
		return cache[i]
	}
	return dfs(len(nums) - 1)
}

//ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­åŒæŒ‡é’ˆğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­//

// ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚
//
// æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº target çš„é•¿åº¦æœ€å°çš„ å­æ•°ç»„
// [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚
func minSubArrayLen(target int, nums []int) int {
	//é€šè¿‡whileå¾ªç¯è®©å·¦æŒ‡é’ˆä¸æ–­å‘å³ç§»åŠ¨å¯»æ‰¾æœ€å°é•¿åº¦ï¼ˆå‰ææ˜¯å½“å‰çª—å£å’Œ>=targetäº†ï¼‰
	n := len(nums)
	left := 0
	right := 0
	ans := n + 1
	sum := 0
	for ; right < n; right++ {
		sum += nums[right]
		for sum >= target {
			ans = min(ans, right-left+1)
			sum -= nums[left]
			left++
		}
	}
	if ans == n+1 {
		return 0
	}
	return ans
}

// ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å­æ•°ç»„å†…æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ä¸¥æ ¼å°äº k çš„è¿ç»­å­æ•°ç»„çš„æ•°ç›®ã€‚
func numSubarrayProductLessThanK(nums []int, k int) int {
	if k <= 1 {
		return 0
	}
	ans := 0
	prod := 1
	var left int
	for right, num := range nums {
		prod *= num
		for prod >= k {
			prod /= nums[left]
			left++
		}
		//å…ƒç´ ä¸ªæ•°ä¸º[l...r]åŒ…å«rçš„è¿ç»­å­æ•°ç»„ä¸ªæ•°ï¼Œå³[l,r],[l+1,r]...[r,r]ï¼Œç­‰äºlåˆ°rçš„é•¿åº¦
		ans += right - left + 1
	}
	return ans
}

// ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ æœ€é•¿ å­ä¸² çš„é•¿åº¦ã€‚
func lengthOfLongestSubstring(s string) int {
	ans := 0
	cntMap := map[int]int{}
	left := 0
	for right, char := range s {
		cntMap[int(char)]++
		//å³æŒ‡é’ˆå‘å³ä¹‹åï¼Œå¯èƒ½é‡å¤çš„åªæœ‰å³æŒ‡é’ˆè¿™ä¸ªå­—ç¬¦çš„é‡å¤ï¼Œ
		for cntMap[int(char)] > 1 {
			cntMap[int(s[left])]--
			left++
		}
		ans = max(ans, right-left+1)
	}
	return ans
}

//ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ç›¸å‘åŒæŒ‡é’ˆğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­//

// ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚
func trap(height []int) int {
	//æ€è·¯ï¼šå½“å‰æŸ±å­èƒ½æ¥çš„é›¨æ°´å–å†³äºå‰ç¼€é«˜åº¦æœ€å¤§å€¼å’Œåç¼€é«˜åº¦æœ€å¤§å€¼å°çš„-å½“å‰æŸ±å­é«˜åº¦
	//éå†3æ¬¡ O(N)æ—¶é—´å¤æ‚åº¦ O(N)ç©ºé—´å¤æ‚åº¦
	n := len(height)
	preMax := make([]int, n)
	sufMax := make([]int, n)
	var temp int
	for i := 0; i < n; i++ {
		temp = max(temp, height[i])
		preMax[i] = temp
	}
	temp = 0
	for i := n - 1; i >= 0; i-- {
		temp = max(temp, height[i])
		sufMax[i] = temp
	}
	ans := 0
	for i := 0; i < n; i++ {
		ans += min(preMax[i], sufMax[i]) - height[i]
	}
	return ans
}

func trapSpaceO1(height []int) int {
	//æ€è·¯ï¼šå¦‚æœå‰ç¼€æœ€å¤§å€¼æ¯”åç¼€æœ€å¤§å€¼å°äº†ï¼Œé‚£ä¹ˆæ— è®ºåç¼€ç»§ç»­å¾€å‰ç§»åŠ¨å¤šå°‘ï¼Œåç¼€æœ€å¤§å€¼ä¸€å®šæ¯”å‰ç¼€æœ€å¤§å€¼è¿˜å¤§ï¼Œ
	//å½“å‰ä¹˜çš„æ°´å°±å¯ä»¥è®¡ç®—å‡ºæ¥äº†ï¼Œæ— éœ€ä¸­é—´çš„æ•°ç»„ï¼Œé‚£ä¹ˆå¯ä»¥åŒæŒ‡é’ˆç›¸å‘ç§»åŠ¨
	n := len(height)
	preMax := height[0]
	sufMax := height[n-1]
	left := 0
	right := n - 1
	ans := 0
	//ä¸´ç•Œæ¡ä»¶ï¼Œç›¸ç­‰çš„æ—¶å€™è®¡ç®—å¯¹åº”é‚£å—æœ¨æ¿æ¥çš„å•ä½
	for left <= right {
		preMax = max(preMax, height[left])
		sufMax = max(sufMax, height[right])
		if preMax < sufMax {
			ans += preMax - height[left]
			left++
		} else {
			ans += sufMax - height[right]
			right--
		}
	}
	return ans
}

//ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­äºŒåˆ†æŸ¥æ‰¾#æ—‹è½¬æ•°ç»„ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­//

// å³°å€¼å…ƒç´ æ˜¯æŒ‡å…¶å€¼ä¸¥æ ¼å¤§äºå·¦å³ç›¸é‚»å€¼çš„å…ƒç´ ã€‚
// ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œæ‰¾åˆ°å³°å€¼å…ƒç´ å¹¶è¿”å›å…¶ç´¢å¼•ã€‚æ•°ç»„å¯èƒ½åŒ…å«å¤šä¸ªå³°å€¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å› ä»»ä½•ä¸€ä¸ªå³°å€¼ æ‰€åœ¨ä½ç½®å³å¯ã€‚
func findPeakElement(nums []int) int {
	l := len(nums)
	//[0,n-2]->(-1,n-1)
	left := -1
	right := l - 1
	for left+1 < right {
		mid := (left + right) / 2
		if nums[mid] > nums[mid+1] {
			//è“è‰²ï¼Œä»£è¡¨å³°é¡¶æˆ–è€…å³°é¡¶å³è¾¹çš„å…ƒç´ 
			right = mid
		} else {
			//çº¢è‰²ï¼Œä»£è¡¨å³°é¡¶å·¦è¾¹
			left = mid
		}
	}
	//è¿”å›æœ€å·¦è¾¹çš„è“è‰²
	return right
}

// å·²çŸ¥ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ï¼Œé¢„å…ˆæŒ‰ç…§å‡åºæ’åˆ—ï¼Œç»ç”± 1 åˆ° n æ¬¡ æ—‹è½¬ åï¼Œå¾—åˆ°è¾“å…¥æ•°ç»„ã€‚ä¾‹å¦‚ï¼ŒåŸæ•°ç»„ nums = [0,1,2,4,5,6,7] åœ¨å˜åŒ–åå¯èƒ½å¾—åˆ°ï¼š
// è‹¥æ—‹è½¬ 4 æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° [4,5,6,7,0,1,2]
// è‹¥æ—‹è½¬ 7 æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° [0,1,2,4,5,6,7]
// æ³¨æ„ï¼Œæ•°ç»„ [a[0], a[1], a[2], ..., a[n-1]] æ—‹è½¬ä¸€æ¬¡ çš„ç»“æœä¸ºæ•°ç»„ [a[n-1], a[0], a[1], a[2], ..., a[n-2]] ã€‚
//
// ç»™ä½ ä¸€ä¸ªå…ƒç´ å€¼ äº’ä¸ç›¸åŒ çš„æ•°ç»„ nums ï¼Œå®ƒåŸæ¥æ˜¯ä¸€ä¸ªå‡åºæ’åˆ—çš„æ•°ç»„ï¼Œå¹¶æŒ‰ä¸Šè¿°æƒ…å½¢è¿›è¡Œäº†å¤šæ¬¡æ—‹è½¬ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­çš„ æœ€å°å…ƒç´  ã€‚
func findMin(nums []int) int {
	l := len(nums)
	//[0,n-2]->(-1,n-1)
	left := -1
	right := l - 1
	for left+1 < right {
		mid := (left + right) / 2
		if nums[mid] < nums[l-1] {
			//è“è‰²ï¼Œ(mid,l-1)æœ‰åºï¼Œmidæ˜¯å³åŒºé—´æœ€å°çš„
			right = mid
		} else {
			//çº¢è‰²ï¼Œåœ¨å³è¾¹Vå­—çš„åŒºé—´
			left = mid
		}
	}
	//è¿”å›æœ€å·¦è¾¹çš„è“è‰²
	return nums[right]
}

// æ•´æ•°æ•°ç»„ nums æŒ‰å‡åºæ’åˆ—ï¼Œæ•°ç»„ä¸­çš„å€¼ äº’ä¸ç›¸åŒ ã€‚
//
// åœ¨ä¼ é€’ç»™å‡½æ•°ä¹‹å‰ï¼Œnums åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ kï¼ˆ0 <= k < nums.lengthï¼‰ä¸Šè¿›è¡Œäº† æ—‹è½¬ï¼Œä½¿æ•°ç»„å˜ä¸º [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]ï¼ˆä¸‹æ ‡ ä» 0 å¼€å§‹ è®¡æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œ [0,1,2,4,5,6,7] åœ¨ä¸‹æ ‡ 3 å¤„ç»æ—‹è½¬åå¯èƒ½å˜ä¸º [4,5,6,7,0,1,2] ã€‚
//
// ç»™ä½  æ—‹è½¬å çš„æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° target ï¼Œå¦‚æœ nums ä¸­å­˜åœ¨è¿™ä¸ªç›®æ ‡å€¼ target ï¼Œåˆ™è¿”å›å®ƒçš„ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1 ã€‚
func search(nums []int, target int) int {
	l := len(nums)
	//[0,n-2]->(-1,n-1)
	left := -1
	right := l - 1
	//è“è‰²ä»£è¡¨å¯ä»¥ç¡®å®šå¾€içš„å·¦è¾¹æ‰¾æ•°ï¼Œä¸è€ƒè™‘å³è¾¹çš„äº†
	isBlue := func(i int) bool {
		end := nums[len(nums)-1]
		if nums[i] > end {
			//æ—‹è½¬åå³è¾¹åˆ†æˆ2æ®µï¼Œå¾€å·¦çš„æ¡ä»¶æ˜¯targetåœ¨(left(>end),nums[i]ä¹‹é—´
			return target > end && target <= nums[i]
		} else {
			//å·¦è¾¹åˆ†æˆ2æ®µï¼Œé‚£ä¹ˆå¾€å·¦æ‰¾çš„æ¡ä»¶å°±æ˜¯targetåœ¨è¿™2æ®µä¸Š
			return target > end || target <= nums[i]
		}
	}
	for left+1 < right {
		mid := (left + right) / 2
		if isBlue(mid) {
			//è“è‰²
			right = mid
		} else {
			//çº¢è‰²
			left = mid
		}
	}
	if nums[right] != target {
		return -1
	}
	//è¿”å›æœ€å·¦è¾¹çš„è“è‰²
	return right
}

// ä¸€ä¸ª 2D ç½‘æ ¼ä¸­çš„ å³°å€¼ æ˜¯æŒ‡é‚£äº› ä¸¥æ ¼å¤§äº å…¶ç›¸é‚»æ ¼å­(ä¸Šã€ä¸‹ã€å·¦ã€å³)çš„å…ƒç´ ã€‚
// ç»™ä½ ä¸€ä¸ª ä» 0 å¼€å§‹ç¼–å· çš„ m x n çŸ©é˜µ mat ï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªç›¸é‚»æ ¼å­çš„å€¼éƒ½ ä¸ç›¸åŒ ã€‚æ‰¾å‡º ä»»æ„ä¸€ä¸ª å³°å€¼ mat[i][j] å¹¶ è¿”å›å…¶ä½ç½® [i,j] ã€‚
func findPeakGrid(mat [][]int) []int {
	left := -1
	right := len(mat) - 1
	findMaxIndex := func(arr []int) int {
		res := 0
		for i, num := range arr {
			if arr[res] < num {
				res = i
			}
		}
		return res
	}
	for left+1 < right {
		mid := (left + right) / 2
		//æ‰¾åˆ°ä¸€è¡Œçš„æœ€å¤§å€¼ï¼Œå³°å€¼è¦ä¹ˆæ˜¯è¿™ä¸ªç‚¹ï¼Œè¦ä¹ˆåœ¨ä¸Šä¸‹ï¼Œæ»¡è¶³å•è°ƒæ€§
		maxIndex := findMaxIndex(mat[mid])
		if mat[mid][maxIndex] < mat[mid+1][maxIndex] {
			//åœ¨å³°å€¼å·¦è¾¹
			left = mid
		} else {
			right = mid
		}
	}
	return []int{right, findMaxIndex(mat[right])}

}
